10、给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

说明:

s 可能为空，且只包含从 a-z 的小写字母。
p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。
示例 1:

输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
示例 2:

输入:
s = "aa"
p = "a*"
输出: true
解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
示例 3:

输入:
s = "ab"
p = ".*"
输出: true
解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
示例 4:

输入:
s = "aab"
p = "c*a*b"
输出: true
解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。
示例 5:

输入:
s = "mississippi"
p = "mis*is*p*."
输出: false

**解题思路**
这道题最麻烦的地方在出现*的情况。
首先从最简单的情况开始，只看要比较的两个字符，即源字符串s[i]和模式串p[j]

如果p[j] == '.'或者p[j] == s[i]：当前匹配成功
如果p[j] == '*'：需要进一步分情况讨论，假设p[j]前面p[j-1]存在
如果p[j-1] == '.'或者p[j-1] == s[i]，则p[j-1]p[j]这两个模式串可以使用1到无数次，匹配成功
如果p[j-1] == '.'和p[j-1] == s[i]都不成立，但可以使用p[j-1]p[j]这两个模式串0次，匹配成功
除了以上情况，均匹配不成功



由于判断p[j] == s[i]、p[j-1]p[j]等当前问题附近的情况，即可减小原问题，因此存在最优子结构，因此可以写出动态规划方程：
记dp[i][j]表示前i个源字符与前j个模式串字符是否匹配（含当前i,j这两个字符）
dp[i][j]就等于：

如果p[j] == '.'或者p[j] == s[i]：当前匹配成功，等于true && dp[i-1][j-1]
如果p[j] == '*'：需要进一步分情况讨论，假设p[j]前面p[j-1]存在
如果p[j-1] == '.'或者p[j-1] == s[i]，则p[j-1]p[j]这两个模式串可以使用1到无数次，匹配成功，等于true && dp[i-1][j]
如果p[j-1] == '.'和p[j-1] == s[i]都不成立，但可以使用p[j-1]p[j]这两个模式串0次，匹配成功，等于true && dp[i-1][j-2]
除了以上情况，均匹配不成功，等于false && dp[i-1][j-1]

**初始解**
动态规划方程根据分析很好写，但是很重要的一点是初始解怎么写
初始解一般是对第一个变量等于0的情况，含义即源字符串为空的时候怎么与模式串P进行匹配

首先想到两个都是空的时候，是匹配的，为true
如果模式串不为空，也要分情况讨论：
对p[j] != '*'，一定是不匹配的
如果p[j] == '*'，那么就存在p[j-1]p[j]这两个模式串使用0次，也可以匹配
因此初始解dp[0][j]可以定义为:

对p[j] != '*'，一定是不匹配的，等于false && dp[0][j-1]
如果p[j] == '*'，那么就存在p[j-1]p[j]这两个模式串使用0次，也可以匹配,等于true && dp[0][j-2]

5、给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

示例 1：

输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
示例 2：

输入: "cbbd"
输出: "bb"



**动态规划**
我们给出 P(i,j) 的定义如下：
如果子串S_i和S_j是回文字符串则P(i,j)为ture
其他情况，P(i,j)为false
因此 P(i,j)=(P(i+1,j−1) and S_i==S_j)
基本示例如下：
P(i, i) = true
P(i, i+1) = ( S_i == S_{i+1} )
这产生了一个直观的动态规划解法，我们首先初始化一字母和二字母的回文，然后找到所有三字母回文，并依此类推…

eg.

| a     | b     | a     | b     | a    |
| ----- | ----- | ----- | ----- | ---- |
| true  |       |       |       |      |
| false | true  |       |       |      |
| true  | false | true  |       |      |
| false | true  | false | true  |      |
| true  | false | true  | false | true |



```c++
class Solution {
public:
    string longestPalindrome(string s) {
        if (s.empty() || s.length() == 0) {
            return "";
        }
        const int n = s.size();
        /*bool f[n][n];
        fill_n(&f[0][0], n*n, false);*/
        //使用vector会超时(也不一定)
        vector<vector<bool> > f(n , vector<bool>(n, false));
        size_t max_len = 1;
        size_t start = 0;

        for(int i = 0; i < s.size(); i++){
            f[i][i] = true;
            for(int j = 0; j < i; j++){
                f[j][i] = (s[j] == s[i] && (i - j < 2 || f[j+1][i-1]));
                if (f[j][i] && max_len < (i-j+1)){
                    max_len = i - j + 1;
                    start = j;
                }
            }
        }
        return s.substr(start, max_len);
    }
};
```

409、给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。

在构造过程中，请注意区分大小写。比如 "Aa" 不能当做一个回文字符串。

注意:
假设字符串的长度不会超过 1010。

示例 1:

输入:
"abccccdd"

输出:
7

解释:
我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。

**思路**

回文串是一个正读和反读都一样的字符串。对一个左边的字符 i 右边一定会有一个对称 i。比如 'abcba'， 'aa'，'bb' 这几个回文串。其中第一个有点特殊，中间的 c 是唯一的。

如果让你来造一个回文串你会怎么造？ 首先让它左右两边绝对对称，如果可能的话再加上一个唯一的中心。

算法

对于每个字母，假设它出现了 v 次。我们可以让 v // 2 * 2 个字母左右对称。例如，对于字符串 'aaaaa'，其中 'aaaa' 是左右对称，其长度为 5 // 2 * 2 = 4。

最后，如果有任何一个满足 v % 2 == 1 的 v，那么这个字符就可能是回文串中唯一的那个中心。针对这种情况，我们需要判断 v % 2 == 1 && ans % 2 == 0，后面的判断主要是为了防止重复计算。

